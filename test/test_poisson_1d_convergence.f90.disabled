program test_poisson_1d_convergence
    ! Unit test for 1D Poisson convergence against analytical solution
    ! Problem: -u'' = f in (0,1), u(0) = u(1) = 0
    ! Analytical solution: u(x) = sin(œÄ*x)
    ! Source term: f(x) = œÄ¬≤*sin(œÄ*x)
    use fortfem_kinds
    use fortfem_mesh_1d
    use fortfem_basis_1d
    use fortfem_assembly_1d
    use fortfem_solver_interface
    implicit none
    
    ! Test parameters
    integer, parameter :: n_refinements = 6
    integer, parameter :: initial_elements = 8
    real(dp), parameter :: pi_const_const = 4.0_dp * atan(1.0_dp)
    real(dp), parameter :: tol = 1e-12_dp
    
    ! Variables
    type(mesh_1d_t) :: mesh
    type(basis_1d_t) :: basis
    real(dp), allocatable :: matrix(:,:), rhs(:), solution(:), exact(:)
    real(dp), allocatable :: h_values(:), l2_errors(:), h1_errors(:)
    real(dp) :: h, l2_error, h1_error, l2_rate, h1_rate
    integer :: n_elements, n_dofs, i, j
    logical :: test_passed
    
    print *, "1D Poisson Convergence Test"
    print *, "============================"
    print *, ""
    print *, "Problem: -u'' = œÄ¬≤sin(œÄx), u(0) = u(1) = 0"
    print *, "Analytical: u(x) = sin(œÄx)"
    print *, ""
    print *, "Expected convergence rates:"
    print *, "  L2 error: O(h¬≤)"
    print *, "  H1 error: O(h)"
    print *, ""
    
    ! Allocate arrays for convergence study
    allocate(h_values(n_refinements))
    allocate(l2_errors(n_refinements))
    allocate(h1_errors(n_refinements))
    
    print '(a8,a12,a12,a12,a8,a8)', "Elements", "h", "L2 error", "H1 error", "L2 rate", "H1 rate"
    print *, "----------------------------------------------------------------"
    
    ! Convergence study
    do i = 1, n_refinements
        n_elements = initial_elements * 2**(i-1)
        h = 1.0_dp / real(n_elements, dp)
        h_values(i) = h
        
        ! Create mesh
        call mesh%create_uniform(n_elements, 0.0_dp, 1.0_dp)
        
        ! Create basis
        call basis%init(mesh)
        n_dofs = basis%n_dofs()
        
        ! Allocate system
        allocate(matrix(n_dofs, n_dofs))
        allocate(rhs(n_dofs))
        allocate(solution(n_dofs))
        allocate(exact(n_dofs))
        
        ! Assemble system
        call assemble_poisson_1d(mesh, basis, matrix, rhs, source_function, &
                                dirichlet_bc, neumann_bc)
        
        ! Solve
        call solve_linear_system(matrix, rhs, solution)
        
        ! Compute exact solution at nodes
        do j = 1, n_dofs
            exact(j) = sin(pi_const * mesh%vertices(j))
        end do
        
        ! Compute errors
        call compute_errors(mesh, basis, solution, exact, l2_error, h1_error)
        
        l2_errors(i) = l2_error
        h1_errors(i) = h1_error
        
        ! Compute convergence rates
        if (i > 1) then
            l2_rate = log(l2_errors(i-1) / l2_errors(i)) / log(2.0_dp)
            h1_rate = log(h1_errors(i-1) / h1_errors(i)) / log(2.0_dp)
            print '(i8,es12.3,es12.3,es12.3,f8.2,f8.2)', n_elements, h, l2_error, h1_error, l2_rate, h1_rate
        else
            print '(i8,es12.3,es12.3,es12.3,a8,a8)', n_elements, h, l2_error, h1_error, "   -", "   -"
        end if
        
        ! Clean up
        deallocate(matrix, rhs, solution, exact)
        call basis%destroy()
        call mesh%destroy()
    end do
    
    print *, ""
    
    ! Check convergence rates
    test_passed = .true.
    
    ! Check L2 convergence rate (should be ~2.0)
    l2_rate = log(l2_errors(n_refinements-1) / l2_errors(n_refinements)) / log(2.0_dp)
    if (abs(l2_rate - 2.0_dp) > 0.2_dp) then
        print *, "‚ùå L2 convergence rate test FAILED"
        print '(a,f6.3,a)', "   Expected: ~2.0, Got: ", l2_rate, ""
        test_passed = .false.
    else
        print *, "‚úÖ L2 convergence rate test PASSED"
        print '(a,f6.3)', "   Rate: ", l2_rate
    end if
    
    ! Check H1 convergence rate (should be ~1.0)
    h1_rate = log(h1_errors(n_refinements-1) / h1_errors(n_refinements)) / log(2.0_dp)
    if (abs(h1_rate - 1.0_dp) > 0.2_dp) then
        print *, "‚ùå H1 convergence rate test FAILED"
        print '(a,f6.3,a)', "   Expected: ~1.0, Got: ", h1_rate, ""
        test_passed = .false.
    else
        print *, "‚úÖ H1 convergence rate test PASSED"
        print '(a,f6.3)', "   Rate: ", h1_rate
    end if
    
    ! Check absolute error on finest mesh
    if (l2_errors(n_refinements) > 1e-4_dp) then
        print *, "‚ùå Absolute error test FAILED"
        print '(a,es12.3)', "   L2 error on finest mesh: ", l2_errors(n_refinements)
        test_passed = .false.
    else
        print *, "‚úÖ Absolute error test PASSED"
        print '(a,es12.3)', "   L2 error on finest mesh: ", l2_errors(n_refinements)
    end if
    
    print *, ""
    if (test_passed) then
        print *, "üéâ ALL TESTS PASSED!"
        print *, "1D Poisson implementation shows optimal convergence rates"
    else
        print *, "‚ùå SOME TESTS FAILED!"
        print *, "Check the finite element implementation"
    end if
    
    ! Clean up
    deallocate(h_values, l2_errors, h1_errors)
    
contains

    ! Source function: f(x) = œÄ¬≤*sin(œÄ*x)
    function source_function(x, y) result(f)
        real(dp), intent(in) :: x, y  ! y unused in 1D
        real(dp) :: f
        f = pi_const**2 * sin(pi_const * x)
    end function source_function
    
    ! Dirichlet boundary conditions: u = 0 at x = 0, 1
    function dirichlet_bc(x, y) result(u)
        real(dp), intent(in) :: x, y  ! y unused in 1D
        real(dp) :: u
        u = 0.0_dp
    end function dirichlet_bc
    
    ! Neumann boundary conditions (unused)
    function neumann_bc(x, y) result(g)
        real(dp), intent(in) :: x, y
        real(dp) :: g
        g = 0.0_dp
    end function neumann_bc
    
    ! Compute L2 and H1 errors
    subroutine compute_errors(mesh, basis, numerical, exact, l2_error, h1_error)
        type(mesh_1d_t), intent(in) :: mesh
        type(basis_1d_t), intent(in) :: basis
        real(dp), intent(in) :: numerical(:), exact(:)
        real(dp), intent(out) :: l2_error, h1_error
        
        integer :: i, j, n_elements, n_quad
        real(dp) :: xi, w, jac, x_phys, u_num, u_exact, du_num, du_exact
        real(dp) :: phi(2), dphi(2), error_u, error_du
        real(dp), parameter :: quad_points(2) = [-0.5773502692_dp, 0.5773502692_dp]
        real(dp), parameter :: quad_weights(2) = [1.0_dp, 1.0_dp]
        
        l2_error = 0.0_dp
        h1_error = 0.0_dp
        n_elements = mesh%n_elements
        n_quad = 2
        
        ! Integrate over all elements
        do i = 1, n_elements
            do j = 1, n_quad
                xi = quad_points(j)
                w = quad_weights(j)
                
                ! Jacobian and physical coordinate
                jac = 0.5_dp * (mesh%vertices(i+1) - mesh%vertices(i))
                x_phys = 0.5_dp * (mesh%vertices(i+1) + mesh%vertices(i)) + xi * jac
                
                ! Basis functions and derivatives
                phi(1) = 0.5_dp * (1.0_dp - xi)
                phi(2) = 0.5_dp * (1.0_dp + xi)
                dphi(1) = -0.5_dp / jac
                dphi(2) = 0.5_dp / jac
                
                ! Numerical solution and derivative
                u_num = numerical(i) * phi(1) + numerical(i+1) * phi(2)
                du_num = numerical(i) * dphi(1) + numerical(i+1) * dphi(2)
                
                ! Exact solution and derivative
                u_exact = sin(pi_const * x_phys)
                du_exact = pi_const * cos(pi_const * x_phys)
                
                ! Errors
                error_u = u_num - u_exact
                error_du = du_num - du_exact
                
                ! Integrate
                l2_error = l2_error + error_u**2 * w * jac
                h1_error = h1_error + (error_u**2 + error_du**2) * w * jac
            end do
        end do
        
        l2_error = sqrt(l2_error)
        h1_error = sqrt(h1_error)
    end subroutine compute_errors

end program test_poisson_1d_convergence