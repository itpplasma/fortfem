program test_poisson_2d_convergence
    ! Unit test for 2D Poisson convergence against analytical solution
    ! Problem: -Œîu = f in (0,1)√ó(0,1), u = 0 on ‚àÇŒ©
    ! Analytical solution: u(x,y) = sin(œÄx)sin(œÄy)
    ! Source term: f(x,y) = 2œÄ¬≤sin(œÄx)sin(œÄy)
    use fortfem_kinds
    use fortfem_mesh_2d
    use fortfem_basis_p1_2d
    use fortfem_assembly_2d
    use fortfem_solver_interface
    implicit none
    
    ! Test parameters
    integer, parameter :: n_refinements = 5
    integer, parameter :: initial_nx = 4
    real(dp), parameter :: pi_const_const = 4.0_dp * atan(1.0_dp)
    real(dp), parameter :: tol = 1e-12_dp
    
    ! Variables
    type(mesh_2d_t) :: mesh
    type(basis_p1_2d_t) :: basis
    real(dp), allocatable :: matrix(:,:), rhs(:), solution(:), exact(:)
    real(dp), allocatable :: h_values(:), l2_errors(:), h1_errors(:)
    real(dp) :: h, l2_error, h1_error, l2_rate, h1_rate
    integer :: nx, ny, n_dofs, i, j
    logical :: test_passed
    
    print *, "2D Poisson Convergence Test"
    print *, "============================"
    print *, ""
    print *, "Problem: -Œîu = 2œÄ¬≤sin(œÄx)sin(œÄy), u = 0 on ‚àÇŒ©"
    print *, "Analytical: u(x,y) = sin(œÄx)sin(œÄy)"
    print *, ""
    print *, "Expected convergence rates:"
    print *, "  L2 error: O(h¬≤)"
    print *, "  H1 error: O(h)"
    print *, ""
    
    ! Allocate arrays for convergence study
    allocate(h_values(n_refinements))
    allocate(l2_errors(n_refinements))
    allocate(h1_errors(n_refinements))
    
    print '(a8,a12,a12,a12,a8,a8)', "Mesh", "h", "L2 error", "H1 error", "L2 rate", "H1 rate"
    print *, "----------------------------------------------------------------"
    
    ! Convergence study
    do i = 1, n_refinements
        nx = initial_nx * 2**(i-1)
        ny = nx
        h = 1.0_dp / real(nx, dp)
        h_values(i) = h
        
        ! Create mesh
        call mesh%create_rectangular(nx, ny, 0.0_dp, 1.0_dp, 0.0_dp, 1.0_dp)
        
        ! Create basis
        call basis%init(mesh)
        n_dofs = basis%n_dofs()
        
        ! Allocate system
        allocate(matrix(n_dofs, n_dofs))
        allocate(rhs(n_dofs))
        allocate(solution(n_dofs))
        allocate(exact(n_dofs))
        
        ! Assemble system
        call assemble_poisson_2d(mesh, basis, matrix, rhs, source_function, &
                                dirichlet_bc, neumann_bc)
        
        ! Solve
        call solve_linear_system(matrix, rhs, solution)
        
        ! Compute exact solution at nodes
        do j = 1, n_dofs
            exact(j) = sin(pi_const * mesh%vertices(1, j)) * sin(pi_const * mesh%vertices(2, j))
        end do
        
        ! Compute errors
        call compute_errors_2d(mesh, basis, solution, exact, l2_error, h1_error)
        
        l2_errors(i) = l2_error
        h1_errors(i) = h1_error
        
        ! Compute convergence rates
        if (i > 1) then
            l2_rate = log(l2_errors(i-1) / l2_errors(i)) / log(2.0_dp)
            h1_rate = log(h1_errors(i-1) / h1_errors(i)) / log(2.0_dp)
            print '(i4,a1,i2,es12.3,es12.3,es12.3,f8.2,f8.2)', nx, "√ó", ny, h, l2_error, h1_error, l2_rate, h1_rate
        else
            print '(i4,a1,i2,es12.3,es12.3,es12.3,a8,a8)', nx, "√ó", ny, h, l2_error, h1_error, "   -", "   -"
        end if
        
        ! Clean up
        deallocate(matrix, rhs, solution, exact)
        call basis%destroy()
        call mesh%destroy()
    end do
    
    print *, ""
    
    ! Check convergence rates
    test_passed = .true.
    
    ! Check L2 convergence rate (should be ~2.0)
    l2_rate = log(l2_errors(n_refinements-1) / l2_errors(n_refinements)) / log(2.0_dp)
    if (abs(l2_rate - 2.0_dp) > 0.3_dp) then
        print *, "‚ùå L2 convergence rate test FAILED"
        print '(a,f6.3,a)', "   Expected: ~2.0, Got: ", l2_rate, ""
        test_passed = .false.
    else
        print *, "‚úÖ L2 convergence rate test PASSED"
        print '(a,f6.3)', "   Rate: ", l2_rate
    end if
    
    ! Check H1 convergence rate (should be ~1.0)
    h1_rate = log(h1_errors(n_refinements-1) / h1_errors(n_refinements)) / log(2.0_dp)
    if (abs(h1_rate - 1.0_dp) > 0.3_dp) then
        print *, "‚ùå H1 convergence rate test FAILED"
        print '(a,f6.3,a)', "   Expected: ~1.0, Got: ", h1_rate, ""
        test_passed = .false.
    else
        print *, "‚úÖ H1 convergence rate test PASSED"
        print '(a,f6.3)', "   Rate: ", h1_rate
    end if
    
    ! Check absolute error on finest mesh
    if (l2_errors(n_refinements) > 1e-3_dp) then
        print *, "‚ùå Absolute error test FAILED"
        print '(a,es12.3)', "   L2 error on finest mesh: ", l2_errors(n_refinements)
        test_passed = .false.
    else
        print *, "‚úÖ Absolute error test PASSED"
        print '(a,es12.3)', "   L2 error on finest mesh: ", l2_errors(n_refinements)
    end if
    
    print *, ""
    if (test_passed) then
        print *, "üéâ ALL TESTS PASSED!"
        print *, "2D Poisson implementation shows optimal convergence rates"
    else
        print *, "‚ùå SOME TESTS FAILED!"
        print *, "Check the finite element implementation"
    end if
    
    ! Clean up
    deallocate(h_values, l2_errors, h1_errors)
    
contains

    ! Source function: f(x,y) = 2œÄ¬≤sin(œÄx)sin(œÄy)
    function source_function(x, y) result(f)
        real(dp), intent(in) :: x, y
        real(dp) :: f
        f = 2.0_dp * pi_const**2 * sin(pi_const * x) * sin(pi_const * y)
    end function source_function
    
    ! Dirichlet boundary conditions: u = 0 on ‚àÇŒ©
    function dirichlet_bc(x, y) result(u)
        real(dp), intent(in) :: x, y
        real(dp) :: u
        u = 0.0_dp
    end function dirichlet_bc
    
    ! Neumann boundary conditions (unused)
    function neumann_bc(x, y) result(g)
        real(dp), intent(in) :: x, y
        real(dp) :: g
        g = 0.0_dp
    end function neumann_bc
    
    ! Compute L2 and H1 errors using quadrature
    subroutine compute_errors_2d(mesh, basis, numerical, exact, l2_error, h1_error)
        type(mesh_2d_t), intent(in) :: mesh
        type(basis_p1_2d_t), intent(in) :: basis
        real(dp), intent(in) :: numerical(:), exact(:)
        real(dp), intent(out) :: l2_error, h1_error
        
        integer :: i, j, n_triangles, n_quad
        real(dp) :: xi, eta, w, jac, x_phys, y_phys
        real(dp) :: u_num, u_exact, du_num_dx, du_num_dy, du_exact_dx, du_exact_dy
        real(dp) :: phi(3), dphi_dx(3), dphi_dy(3)
        real(dp) :: error_u, error_du, area
        integer :: nodes(3)
        
        ! Gauss quadrature points and weights for triangle
        real(dp), parameter :: quad_points(3,3) = reshape([ &
            1.0_dp/6.0_dp, 1.0_dp/6.0_dp, 2.0_dp/3.0_dp, &
            1.0_dp/6.0_dp, 2.0_dp/3.0_dp, 1.0_dp/6.0_dp, &
            2.0_dp/3.0_dp, 1.0_dp/6.0_dp, 1.0_dp/6.0_dp], [3, 3])
        real(dp), parameter :: quad_weights(3) = [1.0_dp/6.0_dp, 1.0_dp/6.0_dp, 1.0_dp/6.0_dp]
        
        l2_error = 0.0_dp
        h1_error = 0.0_dp
        n_triangles = mesh%n_triangles
        n_quad = 3
        
        ! Integrate over all triangles
        do i = 1, n_triangles
            nodes = mesh%triangles(:, i)
            
            ! Compute triangle area
            area = 0.5_dp * abs((mesh%vertices(1, nodes(2)) - mesh%vertices(1, nodes(1))) * &
                               (mesh%vertices(2, nodes(3)) - mesh%vertices(2, nodes(1))) - &
                               (mesh%vertices(1, nodes(3)) - mesh%vertices(1, nodes(1))) * &
                               (mesh%vertices(2, nodes(2)) - mesh%vertices(2, nodes(1))))
            
            do j = 1, n_quad
                xi = quad_points(1, j)
                eta = quad_points(2, j)
                w = quad_weights(j)
                
                ! Physical coordinates
                x_phys = xi * mesh%vertices(1, nodes(1)) + eta * mesh%vertices(1, nodes(2)) + &
                        (1.0_dp - xi - eta) * mesh%vertices(1, nodes(3))
                y_phys = xi * mesh%vertices(2, nodes(1)) + eta * mesh%vertices(2, nodes(2)) + &
                        (1.0_dp - xi - eta) * mesh%vertices(2, nodes(3))
                
                ! Basis functions (barycentric coordinates)
                phi(1) = xi
                phi(2) = eta  
                phi(3) = 1.0_dp - xi - eta
                
                ! Basis function derivatives (simplified for regular mesh)
                call compute_basis_derivatives(mesh, i, dphi_dx, dphi_dy)
                
                ! Numerical solution and derivatives
                u_num = numerical(nodes(1)) * phi(1) + numerical(nodes(2)) * phi(2) + &
                       numerical(nodes(3)) * phi(3)
                du_num_dx = numerical(nodes(1)) * dphi_dx(1) + numerical(nodes(2)) * dphi_dx(2) + &
                           numerical(nodes(3)) * dphi_dx(3)
                du_num_dy = numerical(nodes(1)) * dphi_dy(1) + numerical(nodes(2)) * dphi_dy(2) + &
                           numerical(nodes(3)) * dphi_dy(3)
                
                ! Exact solution and derivatives
                u_exact = sin(pi_const * x_phys) * sin(pi_const * y_phys)
                du_exact_dx = pi_const * cos(pi_const * x_phys) * sin(pi_const * y_phys)
                du_exact_dy = pi_const * sin(pi_const * x_phys) * cos(pi_const * y_phys)
                
                ! Errors
                error_u = u_num - u_exact
                error_du = (du_num_dx - du_exact_dx)**2 + (du_num_dy - du_exact_dy)**2
                
                ! Integrate
                l2_error = l2_error + error_u**2 * w * area
                h1_error = h1_error + (error_u**2 + error_du) * w * area
            end do
        end do
        
        l2_error = sqrt(l2_error)
        h1_error = sqrt(h1_error)
    end subroutine compute_errors_2d
    
    ! Compute basis function derivatives for P1 elements
    subroutine compute_basis_derivatives(mesh, element, dphi_dx, dphi_dy)
        type(mesh_2d_t), intent(in) :: mesh
        integer, intent(in) :: element
        real(dp), intent(out) :: dphi_dx(3), dphi_dy(3)
        
        integer :: nodes(3)
        real(dp) :: x1, y1, x2, y2, x3, y3, det
        
        nodes = mesh%triangles(:, element)
        x1 = mesh%vertices(1, nodes(1))
        y1 = mesh%vertices(2, nodes(1))
        x2 = mesh%vertices(1, nodes(2))
        y2 = mesh%vertices(2, nodes(2))
        x3 = mesh%vertices(1, nodes(3))
        y3 = mesh%vertices(2, nodes(3))
        
        det = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)
        
        ! Derivatives of basis functions
        dphi_dx(1) = (y2 - y3) / det
        dphi_dx(2) = (y3 - y1) / det
        dphi_dx(3) = (y1 - y2) / det
        
        dphi_dy(1) = (x3 - x2) / det
        dphi_dy(2) = (x1 - x3) / det
        dphi_dy(3) = (x2 - x1) / det
    end subroutine compute_basis_derivatives

end program test_poisson_2d_convergence