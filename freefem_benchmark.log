make[1]: Entering directory '/home/ert/code/fortfem/benchmark/freefem/curl-curl'
Running FreeFEM curl-curl benchmark...
FreeFem++ -nw curl_curl_2d.edp
-- FreeFem++ v4.15 (Sat Jul 19 06:53:40 CEST 2025 - git no git)
   file : curl_curl_2d.edp
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue 
    1 : // FreeFEM++ script for 2D curl-curl equation
    2 : // Benchmark reference for FortFEM Nédélec element implementation
    3 : //
    4 : // Problem: curl(curl(E)) + E = f in Ω
    5 : //          E × n = 0 on ∂Ω (essential BC)
    6 : //
    7 : // Exact solution: E = [x*y, x^2]
    8 : // curl(E) = 2*x - x = x
    9 : // curl(curl(E)) = d/dy(x) - d/dx(0) = 0
   10 : // So: f = curl(curl(E)) + E = [0, 0] + [x*y, x^2] = [x*y, x^2]
   11 : 
   12 : load "Element_Mixte"
   13 : 
   14 : // Mesh parameters
   15 : int nx = 20, ny = 20;
   16 : real Lx = 1.0, Ly = 1.0;
   17 : 
   18 : // Create rectangular mesh
   19 : mesh Th = square(nx, ny, [Lx*x, Ly*y]);
   20 : 
   21 : // RT0Ortho = Nédélec edge elements for H(curl) conforming space
   22 : // RT0 is for H(div), RT0Ortho is for H(curl)
   23 : fespace Vh(Th, RT0Ortho);
   24 : Vh [Ex, Ey], [vx, vy];
   25 : 
   26 : // Test with different analytical solutions
   27 : func ExactEx = x*y;
   28 : func ExactEy = x*x;
   29 : func ExactCurl = x;
   30 : 
   31 : // Right-hand side: f = curl(curl(E)) + E
   32 : // For our exact solution: curl(curl(E)) = 0, so f = E
   33 : func fx = x*y;
   34 : func fy = x*x;
   35 : 
   36 : // Bilinear form: a(E,v) = ∫_Ω curl(E)·curl(v) dx + ∫_Ω E·v dx
   37 : // For H(curl), the natural BC is n × E = 0 (tangential component zero)
   38 : // RT0Ortho elements naturally satisfy tangential continuity
   39 : varf curlcurl([Ex, Ey], [vx, vy]) = 
   40 :     int2d(Th)(
   41 :         // curl-curl term: curl(E) * curl(v)
   42 :         (dx(Ey) - dy(Ex)) * (dx(vy) - dy(vx))
   43 :         // mass term: E · v
   44 :         + Ex*vx + Ey*vy
   45 :     )
   46 :     // Essential BC: E_tangent = 0 on boundary
   47 :     // For RT0Ortho, we enforce tangential component = 0
   48 :     + on(1, 2, 3, 4, Ex=0, Ey=0);
   49 : 
   50 : // Linear form: l(v) = ∫_Ω f·v dx
   51 : varf rhs([Ex, Ey], [vx, vy]) = 
   52 :     int2d(Th)(
   53 :         fx*vx + fy*vy
   54 :     )
   55 :     + on(1, 2, 3, 4, Ex=0, Ey=0);
   56 : 
   57 : // Assemble and solve
   58 : matrix A = curlcurl(Vh, Vh);
   59 : real[int] b = rhs(0, Vh);
   60 : 
   61 : // Solve the system
   62 : Ex[] = A^-1 * b;
   63 : 
   64 : // Compute errors
   65 : fespace Ph(Th, P0);  // Piecewise constant for error computation
   66 : Ph errL2, errHcurl;
   67 : 
   68 : // L2 error: ||E - E_exact||_L2
   69 : errL2 = sqrt((Ex - ExactEx)^2 + (Ey - ExactEy)^2);
   70 : 
   71 : // H(curl) error: ||curl(E) - curl(E_exact)||_L2  
   72 : Ph curlE = dx(Ey) - dy(Ex);
   73 : Ph curlExact = ExactCurl;
   74 : errHcurl = abs(curlE - curlExact);
   75 : 
   76 : real L2norm = sqrt(int2d(Th)(errL2^2));
   77 : real Hcurlnorm = sqrt(int2d(Th)(errHcurl^2));
   78 : 
   79 : cout << "Mesh size h = " << 1.0/nx << endl;
   80 : cout << "DOFs = " << Vh.ndof << endl;
   81 : cout << "L2 error = " << L2norm << endl;
   82 : cout << "H(curl) error = " << Hcurlnorm << endl;
   83 : 
   84 : // Output for comparison
   85 : {
   86 :     ofstream file("freefem_results.dat");
   87 :     file << "# h L2_error Hcurl_error DOFs" << endl;
   88 :     file << 1.0/nx << " " << L2norm << " " << Hcurlnorm << " " << Vh.ndof << endl;
   89 : }
   90 : 
   91 : // Convergence study
   92 : if (true) {  // Set to true to run convergence study
   93 :     cout << "\n=== FreeFEM Convergence Study ===" << endl;
   94 :     cout << "h		L2_error	H(curl)_error	DOFs" << endl;
   95 :     
   96 :     ofstream convfile("freefem_convergence.dat");
   97 :     convfile << "# h L2_error Hcurl_error DOFs" << endl;
   98 :     
   99 :     for (int level = 1; level <= 6; level++) {
  100 :         int n = 2 + 2*level;
  101 :         mesh ThConv = square(n, n, [Lx*x, Ly*y]);
  102 :         
  103 :         fespace VhConv(ThConv, RT0Ortho);
  104 :         VhConv [ExConv, EyConv], [vxConv, vyConv];
  105 :         
  106 :         varf curlcurlConv([ExConv, EyConv], [vxConv, vyConv]) = 
  107 :             int2d(ThConv)(
  108 :                 (dx(EyConv) - dy(ExConv)) * (dx(vyConv) - dy(vxConv))
  109 :                 + ExConv*vxConv + EyConv*vyConv
  110 :             )
  111 :             + on(1, 2, 3, 4, ExConv=0, EyConv=0);
  112 :         
  113 :         varf rhsConv([ExConv, EyConv], [vxConv, vyConv]) = 
  114 :             int2d(ThConv)(
  115 :                 fx*vxConv + fy*vyConv
  116 :             )
  117 :             + on(1, 2, 3, 4, ExConv=0, EyConv=0);
  118 :         
  119 :         matrix AConv = curlcurlConv(VhConv, VhConv);
  120 :         real[int] bConv = rhsConv(0, VhConv);
  121 :         ExConv[] = AConv^-1 * bConv;
  122 :         
  123 :         fespace PhConv(ThConv, P0);
  124 :         PhConv errL2Conv = sqrt((ExConv - ExactEx)^2 + (EyConv - ExactEy)^2);
  125 :         PhConv curlEConv = dx(EyConv) - dy(ExConv);
  126 :         PhConv errHcurlConv = abs(curlEConv - ExactCurl);
  127 :         
  128 :         real L2normConv = sqrt(int2d(ThConv)(errL2Conv^2));
  129 :         real HcurlnormConv = sqrt(int2d(ThConv)(errHcurlConv^2));
  130 :         real h = 1.0/n;
  131 :         
  132 :         cout << h << "	" << L2normConv << "	" << HcurlnormConv << "	" << VhConv.ndof << endl;
  133 :         convfile << h << " " << L2normConv << " " << HcurlnormConv << " " << VhConv.ndof << endl;
  134 :     }
  135 :     // convfile closes automatically
  136 : }
  137 : 
  138 : // Visualization (disabled for batch mode)
  139 : // plot([Ex, Ey], wait=true, value=true, fill=true, 
  140 : //      cmm="FreeFEM curl-curl solution E=[Ex,Ey]");
  141 : 
  142 : // Save solution for comparison
  143 : {
  144 :     ofstream solfile("freefem_solution.dat");
  145 :     solfile << "# x y Ex_exact Ey_exact curl_exact" << endl;
  146 :     for (int i = 0; i < Th.nv; i++) {
  147 :         real xi = Th(i).x;
  148 :         real yi = Th(i).y;
  149 :         solfile << xi << " " << yi << " " 
  150 :                 << xi*yi << " " << xi*xi << " " 
  151 :                 << xi << endl;
  152 :     }
  153 : }
  154 : 
  155 : cout << "\nFreeFEM reference solution computed successfull
  ... : y!" << endl;
  156 : cout << "Results saved to freefem_results.dat" << endl;
  157 : cout << "Analytical solution saved to freefem_solution.dat
  ... : " << endl; sizestack + 1024 =7544  ( 6520 )

  -- Square mesh : nb vertices  =441 ,  nb triangles = 800 ,  nb boundary edges 80 rmdup= 0
Mesh size h = 0.05
DOFs = 1240
L2 error = 0.523996
H(curl) error = 0.625541

=== FreeFEM Convergence Study ===
h		L2_error	H(curl)_error	DOFs
  -- Square mesh : nb vertices  =25 ,  nb triangles = 32 ,  nb boundary edges 16 rmdup= 0
0.25	0.516928	0.62129	56
  -- Square mesh : nb vertices  =49 ,  nb triangles = 72 ,  nb boundary edges 24 rmdup= 0
0.166667	0.52109	0.623739	120
  -- Square mesh : nb vertices  =81 ,  nb triangles = 128 ,  nb boundary edges 32 rmdup= 0
0.125	0.522503	0.624603	208
  -- Square mesh : nb vertices  =121 ,  nb triangles = 200 ,  nb boundary edges 40 rmdup= 0
0.1	0.523147	0.625004	320
  -- Square mesh : nb vertices  =169 ,  nb triangles = 288 ,  nb boundary edges 48 rmdup= 0
0.0833333	0.523494	0.625223	456
  -- Square mesh : nb vertices  =225 ,  nb triangles = 392 ,  nb boundary edges 56 rmdup= 0
0.0714286	0.523703	0.625354	616

FreeFEM reference solution computed successfully!
Results saved to freefem_results.dat
Analytical solution saved to freefem_solution.dat
times: compile 0.003098s, execution 0.012867s,  mpirank:0
 ######## unfreed pointers   93 Nb pointer,   0Bytes  ,  mpirank 0, memory leak =275232
 CodeAlloc : nb ptr  4531,  size :553824 mpirank: 0
Ok: Normal End
FreeFEM benchmark completed.
Results:
# h L2_error Hcurl_error DOFs
0.05 0.523996 0.625541 1240
make[1]: Leaving directory '/home/ert/code/fortfem/benchmark/freefem/curl-curl'
